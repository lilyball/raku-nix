#!/usr/bin/env perl

use v5.12;
use version;
use warnings;

sub nix_name
{
    my ($name) = @_;
    $name =~ s/::/-/g;
    $name =~ s/:.*$//;
    $name;
}

sub nix_depends
{
    map { 'rakuPackages."' . nix_name($_) . '"' }
    grep { $_ ne 'NativeCall' }
    @_;
}

if (! -e 'sqlite.sqlite3') {
    say 'WARNING: DOWNLOADING DATABASE WITHOUT TLS!';
    say 'PRESS ENTER TO CONTINUE.';
    scalar(<STDIN>);
    # TODO: Once I get TLS fixed on my server, use HTTPS instead of HTTP.
    system('wget "http://database.crai.foldr.nl/sqlite.sqlite3"')
        and die('wget');
}

open(my $sqlite, '-|', 'sqlite3', 'sqlite.sqlite3', <<'SQL') or die("open: $!");
    SELECT url,
           sha256_hash,
           meta_name,
           meta_version,
           ( SELECT group_concat(meta_depends.meta_depend)
             FROM   meta_depends
             WHERE  meta_depends.archive_url = archives.url )
    FROM   archives
    WHERE  sha256_hash IS NOT NULL AND
           meta_name   IS NOT NULL
SQL

my @libraries;

# First we collect all libraries.
@libraries =
    map {
        chomp;
        my @parts = split(/\|/);
        {
            # Archive properties.
            url            => $parts[0],
            sha256_hash    => $parts[1],

            # Properties from META6.json.
            meta_name      => $parts[2],
            meta_version   => $parts[3],
            meta_version_p => scalar(eval { version->parse($parts[3]) }),
            meta_depends   => [ split(/,/, $parts[4] // '') ],

            # See below.
            meta_build_depends  => [],
            meta_native_depends => [],
        };
    }
    <$sqlite>;

# Some libraries cause obscure issues.
# I have yet to diagnose them.
# Until then, blacklist them.
@libraries =
    grep {
        $_->{url} !~ m:/tadzik/panda/:;
    }
    @libraries;

# Then we throw away garbage input.
# If you want your library in raku-nix,
# you must fix your META6.json.
@libraries =
    grep {
        my $ok = defined($_->{meta_version_p});
        say "DISCARD: $_->{meta_name} @ $_->{meta_version}" unless $ok;
        $ok;
    }
    @libraries;

# Now we keep only the latest version of each library.
my %latest =
    map  { $_->{meta_name} => $_ }
    sort { $a->{meta_version_p} <=> $b->{meta_version_p} }
    @libraries;
@libraries =
    sort { $a->{meta_name} cmp $b->{meta_name} }
    values(%latest);
undef(%latest);

# Insert some known build depends.
# TODO: CRAI should collect these instead.
for (@libraries) {
    if ($_->{meta_name} eq 'FastCGI::NativeCall') {
        $_->{meta_build_depends} = [ qw(LibraryMake Shell::Command) ];
    }
}

# Insert some known native depends.
# TODO: Specify these in a neat place.
for (@libraries) {
    if ($_->{meta_name} eq 'LibCurl') {
        $_->{meta_native_depends} = [ qw(curl) ];
    }
    if ($_->{meta_name} eq 'Cro::TLS') {
        $_->{meta_native_depends} = [ qw(openssl) ];
    }
    if ($_->{meta_name} eq 'Cro::HTTP') {
        # TODO: Propagate from Cro::TLS (#1).
        $_->{meta_native_depends} = [ qw(openssl) ];
    }
}

# Now we generate a Nix derivation for each latest version.
open(my $default, '>', 'packages.nix');
$default->say("# !!! GENERATED BY tools/generate-nix.pl DO NOT EDIT");
$default->say("{ pkgs, rakuPackage }:");
$default->say("pkgs.lib.makeScope pkgs.newScope (self: with self; {");
$default->say("    inherit rakuPackage;");
$default->say("    rakuPackages = {");
for (@libraries) {
    say "LATEST: $_->{meta_name} @ $_->{meta_version}";

    # Nix variables.
    my $url           = $_->{url};
    my $name          = nix_name($_->{meta_name});
    my $sha256        = $_->{sha256_hash};
    my @nativeDepends = $_->{meta_native_depends}->@*;
    my @depends       = nix_depends($_->{meta_depends}->@*);
    my @buildDepends  = nix_depends($_->{meta_build_depends}->@*);

    open(my $nix, '>', "ecosystem/$name.nix") or die("open: $!");
    $nix->say("# !!! GENERATED BY tools/generate-nix.pl DO NOT EDIT");
    $nix->say("{ fetchurl, lib, rakuPackage, rakuPackages,");
    $nix->say(join(',', @nativeDepends) . " }:");
    $nix->say("rakuPackage {");
    $nix->say("    name = \"$name\";");
    $nix->say("    buildDepends = [ @buildDepends ];");
    $nix->say("    depends = [ @depends ];");
    $nix->say("    src = fetchurl {");
    $nix->say("        url = \"$url\";");
    $nix->say("        sha256 = \"$sha256\";");
    $nix->say("    };");
    if (@nativeDepends) {
        # TODO: Do this properly, see #1.
        $nix->say("    preInstallPhase = ''");
        $nix->say("        ldLibraryPath=\${lib.makeLibraryPath [ @nativeDepends ]}");
        $nix->say("        export LD_LIBRARY_PATH=\$ldLibraryPath:\$LD_LIBRARY_PATH");
        $nix->say("    '';");
    }
    $nix->say("}");

    $default->say("        \"$name\" = callPackage (./. + \"/ecosystem/$name.nix\") {};");
}
$default->say("    };");
$default->say("})");

system('tools/generate-ci.bash > .github/workflows/ci.yml')
    and die('tools/generate-ci.bash');
